
# 根据基础类型底层内存对齐指数的不同

|  类型   | 对齐指数  |
|  ----  | ----  |
| bool |  1 |
| int32 |  4 |
| int8 |  1 |
| int64 |  8 |
| byte |  1 |
| string |  8 |
| map |  8 |

# 结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值


# 整体对齐
在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的

# 对齐规则
- 结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍
- 结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值
- 结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的

源自 [在 Go 中恰到好处的内存对齐](https://zhuanlan.zhihu.com/p/53413177)

